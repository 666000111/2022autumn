# Raft
> Raft是一种用于替代Paxos的共识算法。相比于Paxos，Raft的目标是提供更清晰的逻辑分工使得算法本身能被更好地理解，同时它安全性更高，并能提供一些额外的特性.
>
> Raft能为在计算机集群之间部署有限状态机提供一种通用方法，并确保集群内的任意节点在某种状态转换上保持一致。Raft算法的开源实现众多，在Go、C++、Java以及 Scala中都有完整的代码实现。
> 
> Raft这一名字来源于"Reliable, Replicated, Redundant, And Fault-Tolerant"（“可靠、可复制、可冗余、可容错”）的首字母缩写。
> 
> 集群内的节点都对选举出的领袖采取信任，因此Raft不是一种拜占庭容错算法。
> (在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。)
## 简介
Raft透过选举<b>领袖</b>的方式做共识算法。

在Raft集群（英语：Raft cluster）里，服务器可能会是这三种身份其中一个：
* leader
* follower 
* candidate

正常情况下只会存在一个leader，其他均为follower。

leader会负责所有外部请求，如果不是领袖的机器收到时，请求会被导到领袖。

通常领袖会借由固定时间发送消息（心跳 heartbeat），让追随者知道集群的领袖还在运作。
而每个追随者都会设置超时（timout），当超过一定时间没有收到心跳，集群会进入选举状态。

## 具体过程

raft将问题拆成数个子问题去分开解决。

### 领袖选举（leader election）
在算法开始时或是leader死机或断线时，需要选出新领袖。

此时集群进入新的任期（term）并开始选举，如果选举成功则新的领袖开始运行并开始运行工作，
反之则视此任期终止，开始新的任期并开始下一场选举。

选举是由候选人发动的。当领袖的心跳超时的时候，追随者就会将自己的任期编号（term count）加一、宣告竞选、投自己一票、向其他服务器拉票。每个服务器在每个任期只会投自己一票，固定投给最早拉票的服务器。

如果候选者收到来自其他候选者的拉票、并且拉票的任期编号不小于自己的任期编号，就会自认落选，成为追随者，并认定拉票的候选人为领袖，如果有候选人收到过半的选票就当选为新的领袖。
如果超时仍未选出新领袖，该任期自动终止，开始新任期并开始下一场选举。

raft的每个服务器的超时时限是随机的，这降低了多服务器同时竞选的几率，也降低因两个竞选人得票都不过半而选举失败的几率

### 记录复写（log replication）
记录复写的责任在领袖身上。

整个集群有个复写的状态机（state machine）。可执行外来的指令。领袖接受指令，将其写入自己记录中新指令部分，
然后把指令转发给追随者，如果追随者为ack，领袖会不断重发，直到每个追随者都ack为止。

当领袖收到过半的追随者都ack，就会把指令视为committed。当追随者发现指令变为commited，就会在其状态机上运行该指令。

当领袖死机时，领袖的某些新指令可能还没复写到集群整体，造成集群不一致的状态。新领袖会担起重返一致的责任，让每一个追随者记录都和它的一致，做法是和每个追随者比对记录，找出两者一致的最后一笔指令，删除之后的指令，把自己之后的指令拷贝给追随者。
这个机制完成时，每个服务器的记录就会一致。

### 安全性（safety）

* 选举安全性 每个任期最多一个领袖
* 领袖附加性 领袖只会把新指令附加（append）在记录尾端，不会改写或删除指令。
* 记录符合性 如果某个指令在两个记录中的任期和指令序号一样，则保证序号较小的指令也完全一样。
* 领袖完整性 如果某个指令在某个任期中存储成功，则保证存在于领袖该任期之后的记录中。
* 状态机安全性 如果某服务器在其状态机运行了某个指令，其他服务器不会在同个状态上运行不同的指令。